---
title: "EF Core como Sistema Nervioso: AuditorÃ­a AutomÃ¡tica + Eventos de Dominio = Aplicaciones mÃ¡s Inteligentes"
translationId: "ef-core-auditory"
description: "Imagina que tu aplicaciÃ³n reacciona automÃ¡ticamente a cada cambio, registra toda su actividad crÃ­tica y se comunica internamente sin cÃ³digo repetitivo. En este post, revelo cÃ³mo lograr esto usando EF Core como el sistema nervioso central de tu dominio, con dos tÃ©cnicas infalibles: auditorÃ­a automÃ¡tica y eventos de dominio. Incluye el cÃ³digo exacto que utilizo en sistemas empresariales reales."
publishDate: 2025-05-12
tags:
  - DbContext
  - EF
  - C#
  - .NET
  - Azure

img: ""
img_alt: ""
---


# ğŸ§  AuditorÃ­a y PublicaciÃ³n de Eventos de Dominio con EF Core

En este post, exploraremos cÃ³mo utilizar Entity Framework Core para implementar dos patrones fundamentales en aplicaciones empresariales: la **auditorÃ­a de entidades** y la **publicaciÃ³n de eventos de dominio**.

## ğŸ” AuditorÃ­a AutomÃ¡tica de Entidades

EF Core nos permite implementar un sistema de auditorÃ­a automÃ¡tico sobrescribiendo el mÃ©todo **`SaveChangesAsync`**:

```csharp
public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
{
    foreach (var entry in ChangeTracker.Entries<AuditableEntity>())
    {
        switch (entry.State)
        {
            case EntityState.Added:
                entry.Entity.CreatedBy = _currentUserService.UserId;
                entry.Entity.Created = _dateTime.Now;
                break;
            case EntityState.Modified:
                entry.Entity.LastModifiedBy = _currentUserService.UserId;
                entry.Entity.LastModified = _dateTime.Now;
                break;
        }
    }
    // Resto de la implementaciÃ³n...
}
```

## ğŸ¯ Beneficios Clave

- ğŸ›  AutomatizaciÃ³n completa de los campos de auditorÃ­a
- ğŸ”„ Consistencia garantizada en todos los cambios realizados

## ğŸ“Œ CentralizaciÃ³n de la LÃ³gica en un Solo Lugar

_Requisito_: Las entidades deben implementar la clase o interfaz AuditableEntity con propiedades como:

- CreatedBy (quiÃ©n creÃ³ el registro)
- Created (cuÃ¡ndo fue creado)
- LastModifiedBy (Ãºltimo editor)
- LastModified (Ãºltima modificaciÃ³n)

## ğŸŒ Eventos de Dominio con EF Core

El mismo contexto demuestra un patrÃ³n eficiente para manejar eventos de dominio:

```csharp
var events = ChangeTracker.Entries<IHasDomainEvent>()
        .Select(x => x.Entity.DomainEvents)
        .SelectMany(x => x)
        .Where(domainEvent => !domainEvent.IsPublished)
        .ToArray();

var result = await base.SaveChangesAsync(cancellationToken);

await DispatchEvents(events);
```

## âš¡ CaracterÃ­sticas Principales

1. _Flujo de trabajo seguro_:

- âœ… Los cambios se confirman primero en la base de datos
- âœ… Luego se publican los eventos

2. _Mecanismo de prevenciÃ³n de duplicados_:

- ğŸ” Filtra solo eventos no publicados (!domainEvent.IsPublished)
- ğŸ· Marca los eventos como publicados antes de enviarlos

3. _IntegraciÃ³n limpia_:

- ğŸ§© Utiliza una interfaz IHasDomainEvent para identificar entidades con eventos
- ğŸ“¤ Delega la publicaciÃ³n a un servicio especializado (IDomainEventService)

## âš™ï¸ ConfiguraciÃ³n Adicional

El contexto tambiÃ©n incluye configuraciones valiosas para el modelo:

```csharp
protected override void OnModelCreating(ModelBuilder builder)
{
    // Ignorar DomainEvent en el modelo de la DB
    builder.Ignore<DomainEvent>();
    builder.Ignore<List<DomainEvent>>();

    // Configurar DateTime para usar siempre UTC
    foreach (var entityType in builder.Model.GetEntityTypes())
    {
        foreach (var property in entityType.GetProperties())
        {
            if (property.ClrType == typeof(DateTime) || property.ClrType == typeof(DateTime?))
            {
                property.SetValueConverter(new ValueConverter<DateTime, DateTime>(
                    v => v.Kind == DateTimeKind.Utc ? v : DateTime.SpecifyKind(v, DateTimeKind.Utc),
                    v => DateTime.SpecifyKind(v, DateTimeKind.Utc)));
            }
        }
    }
}
```

## ğŸ† ConclusiÃ³n

Este enfoque nos ofrece:

- ğŸ“Š AuditorÃ­a robusta y automÃ¡tica
- ğŸš€ Eventos de dominio confiables
- â± Manejo profesional de fechas en formato UTC
- ğŸ’ Una integraciÃ³n elegante dentro del propio DbContext
