---
title: "EF Core as Nervous System: Automatic Auditing + Domain Events = Smarter Applications"
description: "Imagine your application automatically reacts to every change, logs all its critical activity, and communicates internally without repetitive code. In this post, I reveal how to achieve this using EF Core as the central nervous system of your domain, with two foolproof techniques: automatic auditing and domain events. Includes the exact code I use in real enterprise systems."
publishDate: 2025-05-12
tags:
  - DbContext
  - EF
  - C#
  - .NET
img: ""
img_alt: ""
---

# ğŸ§  Auditing and Domain Event Publishing with EF Core

In this post, we will explore how to use Entity Framework Core to implement two fundamental patterns in enterprise applications: **entity auditing** and **domain event publishing**.

## ğŸ” Automatic Entity Auditing

EF Core allows us to implement an automatic auditing system by overriding the **`SaveChangesAsync`** method:

```csharp
public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
{
    foreach (var entry in ChangeTracker.Entries<AuditableEntity>())
    {
        switch (entry.State)
        {
            case EntityState.Added:
                entry.Entity.CreatedBy = _currentUserService.UserId;
                entry.Entity.Created = _dateTime.Now;
                break;
            case EntityState.Modified:
                entry.Entity.LastModifiedBy = _currentUserService.UserId;
                entry.Entity.LastModified = _dateTime.Now;
                break;
        }
    }
    // Rest of the implementation...
}
```

## ğŸ¯ Key Benefits

- ğŸ›  Complete automation of audit fields
- ğŸ”„ Guaranteed consistency across all changes

## ğŸ“Œ Centralizing Logic in a Single Place

_Requirement_: Entities must implement AuditableEntity with properties such as:

- CreatedBy (who created the record)
- Created (when it was created)
- LastModifiedBy (last editor)
- LastModified (last modification)

## ğŸŒ Domain Events with EF Core

The same context demonstrates an efficient pattern for handling domain events:

```csharp
var events = ChangeTracker.Entries<IHasDomainEvent>()
        .Select(x => x.Entity.DomainEvents)
        .SelectMany(x => x)
        .Where(domainEvent => !domainEvent.IsPublished)
        .ToArray();

var result = await base.SaveChangesAsync(cancellationToken);

await DispatchEvents(events);
```

## âš¡ Main Features

1. _Safe workflow_:

- âœ… Changes are first committed to the database
- âœ… Then events are published

2. _Duplicate prevention mechanism_:

- ğŸ” Filters only unpublished events (!domainEvent.IsPublished)
- ğŸ· Marks events as published before sending them

3. _Clean integration_:

- ğŸ§© Uses an IHasDomainEvent interface to identify entities with events
- ğŸ“¤ Delegates publishing to a specialized service (IDomainEventService)

## âš™ï¸ Additional Configuration

The context also includes valuable configurations:

```csharp
protected override void OnModelCreating(ModelBuilder builder)
{
    // Ignore DomainEvent in the model
    builder.Ignore<DomainEvent>();
    builder.Ignore<List<DomainEvent>>();

    // Configure DateTime to use UTC
    foreach (var entityType in builder.Model.GetEntityTypes())
    {
        foreach (var property in entityType.GetProperties())
        {
            if (property.ClrType == typeof(DateTime) || property.ClrType == typeof(DateTime?))
            {
                property.SetValueConverter(new ValueConverter<DateTime, DateTime>(
                    v => v.Kind == DateTimeKind.Utc ? v : DateTime.SpecifyKind(v, DateTimeKind.Utc),
                    v => DateTime.SpecifyKind(v, DateTimeKind.Utc)));
            }
        }
    }
}
```

## ğŸ† Conclusion

This approach offers us:

- ğŸ“Š Robust and automatic auditing
- ğŸš€ Reliable domain events
- â± Professional UTC date handling
- ğŸ’ Elegant integration into the DbContext
