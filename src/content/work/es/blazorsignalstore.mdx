---
title: "BlazorSignalStore: Una forma sencilla de gestionar el estado en Blazor"
translationId: "blazorsignalstore"
subtitle: "Gesti√≥n de Estado Reactiva para Aplicaciones Blazor Modernas"
publishDate: 2025-11-02 18:00:00
lastModified: 2025-11-02 18:00:00
author: "TempooDev"
img: ""
img_alt: "Comparaci√≥n de rendimiento entre BlazorSignalStore y el patr√≥n Container State de Microsoft mostrando un 50% menos de re-renderizados"
description: |
    Descubre c√≥mo BlazorSignalStore revoluciona la gesti√≥n de estado en aplicaciones Blazor con reactividad granular, 
    eliminando c√≥digo repetitivo mientras ofrece un 50% menos de re-renderizados comparado con el patr√≥n Container State de Microsoft. 
    Aprende las diferencias, mira comparaciones de rendimiento y entiende cu√°ndo usar cada enfoque en tus proyectos.
excerpt: |
    Una comparaci√≥n completa entre BlazorSignalStore y el patr√≥n Container State de Microsoft, 
    demostrando c√≥mo la programaci√≥n reactiva puede mejorar significativamente tanto la experiencia del desarrollador como el rendimiento de la aplicaci√≥n.
keywords:
  - BlazorSignalStore
  - Gesti√≥n de estado Blazor
  - programaci√≥n reactiva
  - Microsoft Container State
  - Patr√≥n Signal
  - Rendimiento Blazor
  - Gesti√≥n de estado .NET
  - reactividad granular
  - optimizaci√≥n de formularios
  - Blazor WebAssembly
category: "Desarrollo"
tags: 
  - Blazor
  - Gesti√≥n de Estado
  - Programaci√≥n Reactiva
  - Rendimiento
  - .NET
  - NuGet
  - WebAssembly
  - Desarrollo de Componentes
  - Arquitectura Frontend
  - Experiencia de Desarrollador
readTime: "8 min de lectura"
difficulty: "Intermedio"
toc: true
featured: true
series: "Gesti√≥n de Estado en Blazor"
socialShare:
  twitter: "Descubre c√≥mo @BlazorSignalStore ofrece un 50% menos de re-renderizados comparado con el patr√≥n Container State de Microsoft üöÄ #Blazor #StateManagement #ReactiveProgramming"
  linkedin: "Aprende c√≥mo BlazorSignalStore revoluciona la gesti√≥n de estado en Blazor con reactividad granular y rendimiento superior"
  facebook: "BlazorSignalStore vs Container State: Una comparaci√≥n completa de rendimiento y experiencia de desarrollador"
meta:
  canonical: "https://tempoodev.github.io/blazor-signal-store-comparison"
  robots: "index, follow"
  language: "es-ES"
schema:
  type: "TechArticle"
  proficiencyLevel: "Intermediate"
  about: "Comparaci√≥n de gesti√≥n de estado en Blazor"
  teaches: ["Programaci√≥n reactiva en Blazor", "Optimizaci√≥n de rendimiento", "Patrones de gesti√≥n de estado"]
---

## Introducci√≥n

BlazorSignalStore es una soluci√≥n moderna para la gesti√≥n de estado en aplicaciones Blazor. Despu√©s de trabajar en varios proyectos Blazor utilizando el patr√≥n Container State propuesto por Microsoft, not√© cantidades significativas de c√≥digo repetitivo: suscripciones manuales en `OnInitialized`, implementaciones de `IDisposable` en cada componente suscrito, y la necesidad de disparar manualmente los cambios de estado. Adem√°s, cualquier cambio de propiedad causaba que componentes enteros se re-renderizaran innecesariamente.

Aqu√≠ es donde brilla BlazorSignalStore: proporciona reactividad granular que solo re-renderiza las partes espec√≠ficas de la UI que realmente cambiaron.

## Patr√≥n Container State

Microsoft recomienda usar una clase como contenedor e inyectarla en el contenedor de inyecci√≥n de dependencias como Scoped.

``` csharp
// Program.cs
builder.Services.AddScoped<ContainerStateService>();

```
Necesitas una clase que describa el estado y las acciones que se pueden realizar sobre √©l:
```csharp
// FormContainerState.cs
public record FormContainerState
    {
        public PersonalInfo PersonalInfo { get; init; } = new();
        public Address Address { get; init; } = new();
        public UserPreferencesData Preferences { get; init; } = new();
        public bool IsSubmitting { get; init; } = false;
        public SubmissionResult? SubmissionResult { get; init; } = null;

        // L√≥gica de validaci√≥n dentro del contenedor
        public bool IsValid()
        {
            return PersonalInfo.IsValid() && Address.IsValid() && Preferences.IsValid();
        }

        public bool CanSubmit()
        {
            return IsValid() && !IsSubmitting;
        }

        public List<string> GetValidationErrors()
        {
            var errors = new List<string>();
            errors.AddRange(PersonalInfo.GetValidationErrors());
            errors.AddRange(Address.GetValidationErrors());
            errors.AddRange(Preferences.GetValidationErrors());
            return errors;
        }

        public double GetCompletionPercentage()
        {
            var totalFields = 9; // Total de campos requeridos
            var completedFields = 0;

            if (!string.IsNullOrWhiteSpace(PersonalInfo.FirstName)) completedFields++;
            if (!string.IsNullOrWhiteSpace(PersonalInfo.LastName)) completedFields++;
            if (!string.IsNullOrWhiteSpace(PersonalInfo.Email)) completedFields++;
            if (!string.IsNullOrWhiteSpace(Address.Street)) completedFields++;
            if (!string.IsNullOrWhiteSpace(Address.City)) completedFields++;
            if (!string.IsNullOrWhiteSpace(Address.PostalCode)) completedFields++;
            if (!string.IsNullOrWhiteSpace(Address.Country)) completedFields++;
            if (!string.IsNullOrWhiteSpace(Preferences.Theme)) completedFields++;
            if (Preferences.EmailNotifications || Preferences.SmsNotifications) completedFields++;

            return (double)completedFields / totalFields * 100;
        }
    }
```

El contenedor de estado declara acciones y notifica a los suscriptores cuando ocurren cambios:
```csharp
// ContainerStateService.cs 

    public class ContainerStateService
    {
        private FormContainerState _formState = new();
        
        public event Action? OnChange;

        public FormContainerState FormState => _formState;

        // Propiedades derivadas del estado del contenedor
        public bool IsFormValid => _formState.IsValid();
        public bool CanSubmit => _formState.CanSubmit();
        public List<string> ValidationErrors => _formState.GetValidationErrors();
        public double FormCompletionPercentage => _formState.GetCompletionPercentage();

        // Acciones que modifican el estado del contenedor
        public void UpdatePersonalInfo(string firstName, string lastName, string email)
        {
            _formState = _formState with
            {
                PersonalInfo = _formState.PersonalInfo with
                {
                    FirstName = firstName,
                    LastName = lastName,
                    Email = email
                }
            };
            NotifyStateChanged();
        }

        public void UpdateAddress(string street, string city, string postalCode, string country)
        {
            _formState = _formState with
            {
                Address = _formState.Address with
                {
                    Street = street,
                    City = city,
                    PostalCode = postalCode,
                    Country = country
                }
            };
            NotifyStateChanged();
        }

        public void UpdatePreferences(bool emailNotifications, bool smsNotifications, string theme)
        {
            _formState = _formState with
            {
                Preferences = _formState.Preferences with
                {
                    EmailNotifications = emailNotifications,
                    SmsNotifications = smsNotifications,
                    Theme = theme
                }
            };
            NotifyStateChanged();
        }

        private void NotifyStateChanged() => OnChange?.Invoke();
    }
```

Para usarlo, inyectas el servicio/contenedor de estado e implementas `IDisposable` para cancelar suscripciones cuando termina el ciclo de vida del componente:
``` html
<!-- ContainerExample.razor -->
@page "/container-state"
@using BlazorSignalStore.Demo.Store
@inject ContainerStateService ContainerStateService
@implements IDisposable

<PageTitle>Container State Demo - BlazorSignalStore</PageTitle>

<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <h1 class="display-4 text-center mb-4">üì¶ Demo Patr√≥n Container State</h1>
            <p class="lead text-center mb-5">
                Esta demo muestra el patr√≥n Container State recomendado por Microsoft para aplicaciones Blazor.
                En lugar de gestionar propiedades de estado individuales, todo el estado relacionado se agrupa en un solo contenedor.
            </p>
        </div>
    </div>

    <!-- Barra de Progreso -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card shadow-sm">
                <div class="card-header bg-primary text-white">
                    <h5 class="mb-0">üìä Progreso del Formulario</h5>
                </div>
                <div class="card-body">
                    <div class="progress mb-2" style="height: 25px;">
                        <div class="progress-bar progress-bar-striped @(ContainerStateService.FormCompletionPercentage == 100 ? "bg-success" : "")"
                             style="width: @ContainerStateService.FormCompletionPercentage%">
                            @ContainerStateService.FormCompletionPercentage.ToString("F0")%
                        </div>
                    </div>
                    <small class="text-muted">Completa todos los campos para habilitar el env√≠o</small>
                </div>
            </div>
        </div>
    </div>

    <!-- Ejemplo de Formulario -->
    <div class="row">
        <div class="col-md-6">
            <input type="text" class="form-control mb-2" placeholder="Nombre"
                   value="@ContainerStateService.FormState.PersonalInfo.FirstName"
                   @onchange="@(e => UpdatePersonalInfo(e.Value?.ToString() ?? "", 
                                                       ContainerStateService.FormState.PersonalInfo.LastName,
                                                       ContainerStateService.FormState.PersonalInfo.Email))" />
        </div>
        <div class="col-md-6">
            <input type="text" class="form-control mb-2" placeholder="Apellido"
                   value="@ContainerStateService.FormState.PersonalInfo.LastName"
                   @onchange="@(e => UpdatePersonalInfo(ContainerStateService.FormState.PersonalInfo.FirstName,
                                                       e.Value?.ToString() ?? "",
                                                       ContainerStateService.FormState.PersonalInfo.Email))" />
        </div>
    </div>
</div>

@code {
    protected override void OnInitialized()
    {
        ContainerStateService.OnChange += StateHasChanged;
    }

    private void UpdatePersonalInfo(string firstName, string lastName, string email)
    {
        ContainerStateService.UpdatePersonalInfo(firstName, lastName, email);
    }

    private void UpdateAddress(string street, string city, string postalCode, string country)
    {
        ContainerStateService.UpdateAddress(street, city, postalCode, country);
    }

    private void UpdatePreferences(bool emailNotifications, bool smsNotifications, string theme)
    {
        ContainerStateService.UpdatePreferences(emailNotifications, smsNotifications, theme);
    }

    public void Dispose()
    {
        ContainerStateService.OnChange -= StateHasChanged;
    }
}
```

### El Problema con Container State

El problema con esta soluci√≥n es que siempre tenemos c√≥digo repetitivo para suscribirnos y desuscribirnos de los cambios de estado. El problema principal es que al recibir cambios en cualquier propiedad, el componente completo se re-renderiza. Esto significa que si tenemos un formulario y modificamos el nombre, todo el componente se re-renderizar√° debido a la suscripci√≥n al cambio de estado.

Aqu√≠ es donde brilla la reactividad de Signals, ya que solo las partes espec√≠ficas que han sido modificadas se re-renderizar√°n parcialmente.

## BlazorSignalStore 

Esta implementaci√≥n simplifica la experiencia de desarrollo eliminando el c√≥digo boilerplate y optimizando la soluci√≥n para evitar re-renderizados cuando se modifica una sola propiedad del estado.

```csharp
// Program.cs
builder.Services.AddSignalStore<SignalFormStore>();
```

Declaraci√≥n del Store con propiedades agrupadas en Signals y propiedades Computadas:
``` csharp
// SignalFormStore.cs
using BlazorSignalStore.Core;

namespace BlazorSignalStore.Demo.Store
{
    /// <summary>
    /// Un store de formulario demostrando reactividad granular con Signals.
    /// Cada propiedad es su propio Signal, permitiendo actualizaciones precisas de la UI.
    /// </summary>
    public class SignalFormStore : StoreBase
    {
        // Signals de Informaci√≥n Personal
        public Signal<string> FirstName { get; } = new("");
        public Signal<string> LastName { get; } = new("");
        public Signal<string> Email { get; } = new("");
        
        // Signals de Direcci√≥n
        public Signal<string> Street { get; } = new("");
        public Signal<string> City { get; } = new("");
        public Signal<string> PostalCode { get; } = new("");
        public Signal<string> Country { get; } = new("");
        
        // Signals de Preferencias
        public Signal<bool> EmailNotifications { get; } = new(false);
        public Signal<bool> SmsNotifications { get; } = new(false);
        public Signal<string> Theme { get; } = new("light");
        
        // Propiedades computadas para validaci√≥n y progreso
        public Computed<bool> IsPersonalInfoValid { get; }
        public Computed<bool> IsAddressValid { get; }
        public Computed<bool> IsFormValid { get; }
        public Computed<double> FormProgress { get; }
        
        public SignalFormStore()
        {
            IsPersonalInfoValid = new Computed<bool>(() => 
                !string.IsNullOrWhiteSpace(FirstName.Value) &&
                !string.IsNullOrWhiteSpace(LastName.Value) &&
                !string.IsNullOrWhiteSpace(Email.Value), 
                FirstName, LastName, Email);
                
            IsAddressValid = new Computed<bool>(() => 
                !string.IsNullOrWhiteSpace(Street.Value) &&
                !string.IsNullOrWhiteSpace(City.Value) &&
                !string.IsNullOrWhiteSpace(PostalCode.Value) &&
                !string.IsNullOrWhiteSpace(Country.Value), 
                Street, City, PostalCode, Country);
                
            IsFormValid = new Computed<bool>(() => 
                IsPersonalInfoValid.Value && IsAddressValid.Value, 
                IsPersonalInfoValid, IsAddressValid);
                
            FormProgress = new Computed<double>(() => 
            {
                var completedFields = 0;
                var totalFields = 9;
                
                if (!string.IsNullOrWhiteSpace(FirstName.Value)) completedFields++;
                if (!string.IsNullOrWhiteSpace(LastName.Value)) completedFields++;
                if (!string.IsNullOrWhiteSpace(Email.Value)) completedFields++;
                if (!string.IsNullOrWhiteSpace(Street.Value)) completedFields++;
                if (!string.IsNullOrWhiteSpace(City.Value)) completedFields++;
                if (!string.IsNullOrWhiteSpace(PostalCode.Value)) completedFields++;
                if (!string.IsNullOrWhiteSpace(Country.Value)) completedFields++;
                if (!string.IsNullOrWhiteSpace(Theme.Value)) completedFields++;
                if (EmailNotifications.Value || SmsNotifications.Value) completedFields++;
                
                return (double)completedFields / totalFields * 100;
            }, FirstName, LastName, Email, Street, City, PostalCode, Country, Theme, EmailNotifications, SmsNotifications);
        }
    }
}
```

El uso en el componente se simplifica. Solo inyectas el Store y a√±ades los Signals en OnInitialized. Los propios Signals manejan la l√≥gica de renderizado y la notificaci√≥n de cambios autom√°ticamente:

```html
<!-- SignalFormExample.razor -->
@page "/signal-form"
@using BlazorSignalStore.Demo.Store
@using BlazorSignalStore.Core
@inject SignalFormStore SignalFormStore

<PageTitle>Demo Formulario Signal - BlazorSignalStore</PageTitle>

<div class="container-fluid">
    <div class="row">
        <div class="col-12">
            <h1 class="display-4 text-center mb-4">‚ö° Demo Formulario Signal</h1>
            <p class="lead text-center mb-5">
                Esta demo muestra la reactividad granular de BlazorSignalStore: solo las partes espec√≠ficas de la UI que dependen de se√±ales modificadas se re-renderizar√°n.
            </p>
        </div>
    </div>

    <!-- Barra de Progreso -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card shadow-sm">
                <div class="card-header bg-success text-white">
                    <h5 class="mb-0">üìä Progreso del Formulario (Reactivo)</h5>
                </div>
                <div class="card-body">
                    <div class="progress mb-2" style="height: 25px;">
                        <div class="progress-bar progress-bar-striped @(formProgress() == 100 ? "bg-success" : "")"
                             style="width: @formProgress()%">
                            @formProgress().ToString("F0")%
                        </div>
                    </div>
                    <small class="text-muted">Completa todos los campos para habilitar el env√≠o</small>
                </div>
            </div>
        </div>
    </div>

    <!-- Campos del Formulario -->
    <div class="row">
        <div class="col-md-6">
            <input type="text" class="form-control mb-2" placeholder="Nombre"
                   value="@firstName()"
                   @onchange="@(e => SignalFormStore.FirstName.Value = e.Value?.ToString() ?? "")" />
        </div>
        <div class="col-md-6">
            <input type="text" class="form-control mb-2" placeholder="Apellido"
                   value="@lastName()"
                   @onchange="@(e => SignalFormStore.LastName.Value = e.Value?.ToString() ?? "")" />
        </div>
    </div>
</div>

@code {
    private Func<string>? firstName;
    private Func<string>? lastName;
    private Func<string>? email;
    private Func<double>? formProgress;
    private Func<bool>? isFormValid;

    protected override void OnInitialized()
    {
        firstName = this.useSignal(SignalFormStore.FirstName);
        lastName = this.useSignal(SignalFormStore.LastName);
        email = this.useSignal(SignalFormStore.Email);
        formProgress = this.useSignal(SignalFormStore.FormProgress);
        isFormValid = this.useSignal(SignalFormStore.IsFormValid);
    }
}
```

## Comparaci√≥n de Rendimiento

Nuestra aplicaci√≥n de demostraci√≥n incluye una comparaci√≥n lado a lado que demuestra los beneficios de rendimiento de BlazorSignalStore:

### Patr√≥n Container State:
- **Re-renderizados**: Cuando cualquier campo cambia, todo el componente se re-renderiza
- **Rendimiento**: ~100% tasa de re-renderizado para interacciones de formulario
- **C√≥digo**: Requiere gesti√≥n de suscripci√≥n manual e implementaci√≥n de IDisposable

### BlazorSignalStore:
- **Re-renderizados**: Solo los elementos espec√≠ficos de la UI que dependen de la se√±al cambiada se re-renderizan
- **Rendimiento**: ~50% menos re-renderizados comparado con Container State
- **C√≥digo**: Gesti√≥n autom√°tica de suscripciones, sin necesidad de boilerplate

## Ventajas Clave de BlazorSignalStore

### üöÄ **Beneficios de Rendimiento**
1. **Reactividad Granular**: Solo las partes afectadas de la UI se re-renderizan
2. **Uso Reducido de CPU**: Menos ciclos de renderizado innecesarios
3. **Mejor Experiencia de Usuario**: Interacciones m√°s fluidas en formularios complejos

### üõ†Ô∏è **Experiencia de Desarrollador**
1. **Menos Boilerplate**: Sin necesidad de gesti√≥n manual de suscripciones
2. **Sin IDisposable**: Limpieza autom√°tica manejada por la librer√≠a
3. **Seguridad de Tipos**: Tipado fuerte con Signal&lt;T&gt; y Computed&lt;T&gt; gen√©ricos
4. **API Intuitiva**: Similar a frameworks reactivos modernos

### üìä **Escalabilidad**
1. **Formularios Grandes**: Los beneficios de rendimiento aumentan con la complejidad del formulario
2. **Estado Complejo**: F√°cil de gestionar estado interdependiente con se√±ales Computadas
3. **Eficiencia de Memoria**: La limpieza autom√°tica de suscripciones previene fugas de memoria

## Cu√°ndo Usar Cada Patr√≥n

### Usa Container State Cuando:
- ‚úÖ Aplicaciones simples con necesidades m√≠nimas de gesti√≥n de estado
- ‚úÖ Se requiere seguir patrones estrictos de Microsoft
- ‚úÖ El equipo no est√° familiarizado con conceptos de programaci√≥n reactiva

### Usa BlazorSignalStore Cuando:
- ‚úÖ Construyes formularios complejos con muchos campos
- ‚úÖ La optimizaci√≥n del rendimiento es importante
- ‚úÖ Quieres una gesti√≥n de estado reactiva moderna
- ‚úÖ Reducir el c√≥digo boilerplate es una prioridad
- ‚úÖ Construyes aplicaciones de gran escala

## Conclusi√≥n

Mientras que el patr√≥n Container State de Microsoft proporciona una base s√≥lida para la gesti√≥n de estado en Blazor, **BlazorSignalStore ofrece ventajas significativas** tanto en rendimiento como en experiencia de desarrollador:

1. **~50% menos re-renderizados** en escenarios t√≠picos de formularios
2. **Elimina c√≥digo boilerplate** para la gesti√≥n de suscripciones
3. **Proporciona reactividad granular** similar a frameworks frontend modernos
4. **Mantiene la seguridad de tipos** y sigue las convenciones de .NET
5. **Escala mejor** para aplicaciones complejas

BlazorSignalStore trae lo mejor de la programaci√≥n reactiva a Blazor mientras mantiene la experiencia de desarrollo familiar de C#. Es particularmente valioso para aplicaciones con formularios complejos, datos en tiempo real o escenarios cr√≠ticos de rendimiento.

La librer√≠a prueba que no tienes que elegir entre rendimiento y experiencia de desarrollador - puedes tener ambos.

---

**Prueba BlazorSignalStore hoy** y experimenta la diferencia que hace la reactividad granular en tus aplicaciones Blazor!

```bash
dotnet add package BlazorSignalStore
```

Para m√°s ejemplos y documentaci√≥n, visita nuestro [repositorio de GitHub](https://github.com/TempooDev/BlazorSignalStore).
